Front End Notes: 

-1. What is React? What do you like/dislike about React?
    React is an open-source frontend JavaScript library which is used for building user interfaces especially for single page applications. 
    It is used for handling view layer for web and mobile apps. React was created by Jordan Walke, a software engineer working for Facebook. 
    React was first deployed on Facebook's News Feed in 2011 and on Instagram in 2012.

    Like: I love how its essentially Advanced Javascript with HTML and CSS sprinkled in. the ability to manipulate data within each component
        and the ability to see your changes that you make through the server side rendering is amazing. I love that it is also Unidirectional.
    Dislike: Mainly how fast it is being upgraded. Changes are made to React at an alarming rate and sometimes its hard to keep up with all
        the new features introduced. 

0. What are the major features of React?
    The major features of React are:

        It uses VirtualDOM instead of RealDOM considering that RealDOM manipulations are expensive.
        Supports server-side rendering.
        Follows Unidirectional data flow or data binding.
        Uses reusable/composable UI components to develop the view.

1. What are the different phases of component lifecycle?
    The component lifecycle has three distinct lifecycle phases:

        Mounting: The component is ready to mount in the browser DOM. This phase covers initialization from constructor(), getDerivedStateFromProps(), render(), 
        and componentDidMount() lifecycle methods.

        Updating: In this phase, the component get updated in two ways, sending the new props and updating the state either from setState() or forceUpdate(). 
        This phase covers getDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate() and componentDidUpdate() lifecycle methods.

        Unmounting: In this last phase, the component is not needed and get unmounted from the browser DOM. This phase includes componentWillUnmount() lifecycle method.

        It's worth mentioning that React internally has a concept of phases when applying changes to the DOM. They are separated as follows

        Render The component will render without any side-effects. This applies for Pure components and in this phase, React can pause, abort, or restart the render.

        Pre-commit Before the component actually applies the changes to the DOM, there is a moment that allows React to read from the DOM through the getSnapshotBeforeUpdate().

        Commit React works with the DOM and executes the final lifecycles respectively componentDidMount() for mounting, componentDidUpdate() for updating, and componentWillUnmount() 
        for unmounting.

2. Why do we use arrow functions in react?
    simple: In react you can have on-click handlers. Its not really a class method, its a class property. utilizing arrow functions gets rid of the issue where you have a function 
    within a class and you are utilizing the this keyword. With a regular function, you can only refer to what variables are inside of that function, whereas with an arrow function 
    you are able to assess the state in the main class component by calling this.state.
    Arrow functions also make it possible to avoid using curly brackets and a the word return when writing one liner functions. (eg. const addition = (a, b) => a + b)

3. How do you prevent components from re-rendering? 
    You can utilize 3 different methods to do so:
        1. shouldComponentUpdate() : before component is rendered it checks should i render or not in this method. You return false it stops the rendering / true it re-renders.
        2. React.PureComponent: React.PureComponent is exactly the same as React.Component except that it handles the shouldComponentUpdate() method for you. When props or state 
            changes, PureComponent will do a shallow comparison on both props and state. Component on the other hand won't compare current props and state to next out of the box. 
            Thus, the component will re-render by default whenever shouldComponentUpdate is called.
        3. React.memo: utilizing memoization. If inputs are the same then output is the same. 
        4. useEffect:

4. What is Unidirectional data flow in React (How does it flow in one direction)? 
    In react whenever you are trying to type into the dom, the dom itself doesnt actually update state. In order to change the screen, you need to change the data. So for a 
    form for instance, in order for the form to be filled as you type, you need to add a function that is setting the state with every keystroke. This is a direct example of 
    Unidirectional flow.

5. What is the difference between state and props?
    State: when a component defines data locally within itself. State is mutable 
    props: when that same data gets passed down to a child component. Props are immutable. Only way to change props is in the parent component where setState is utilized.

6. What does it mean to 'lift state up' in React?
    When several components need to share the same changing data then it is recommended to lift the shared state up to their closest common ancestor. That means if two child 
    components share the same data from its parent, then move the state to parent instead of maintaining local state in both of the child components.

7. What is the difference between a controlled component vs uncontrolled component?
    A component that controls the input elements within the forms on subsequent user input is called Controlled Component, i.e, every state mutation will have an associated 
    handler function.

    For example, to write all the names in uppercase letters, we use handleChange as below,

        handleChange(event) {
        this.setState({value: event.target.value.toUpperCase()})
        }
    
    uncontrolled: The Uncontrolled Components are the ones that store their own state internally, and you query the DOM using a ref to find its current value when you need it. 
    This is a bit more like traditional HTML.

    In the below UserProfile component, the name input is accessed using ref.

        class UserProfile extends React.Component {
        constructor(props) {
            super(props)
            this.handleSubmit = this.handleSubmit.bind(this)
            this.input = React.createRef()
        }

        handleSubmit(event) {
            alert('A name was submitted: ' + this.input.current.value)
            event.preventDefault()
        }

        render() {
            return (
            <form onSubmit={this.handleSubmit}>
                <label>
                {'Name:'}
                <input type="text" ref={this.input} />
                </label>
                <input type="submit" value="Submit" />
            </form>
            );
        }
        }

8. What are Refs in React?
    The ref is used to return a reference to the element. They should be avoided in most cases, however, they can be useful when you need a direct access to the DOM element 
    or an instance of a component without re-rendering.

                                                        import React, { useRef, useEffect } from 'react';
                                                        
                                                        export default function App() {
                                                            const inputRef = useRef();
                                                            useEffect(() => {
                                                                inputRef.current.focus();
                                                            }, [])

                                                            return (
                                                                <div className='App'>
                                                                    <input ref={inputRef} type='text' />
                                                                </div>
                                                            );   
                                                        }
    
9. What is "key" prop and what is the benefit of using it in arrays of elements?
    A key is a special string attribute you should include when creating arrays of elements. Key prop helps React identify which items have changed, are added, or are removed.

    Most often we use ID from our data as key:

        const todoItems = todos.map((todo) =>
        <li key={todo.id}>
            {todo.text}
        </li>
        )

    When you don't have stable IDs for rendered items, you may use the item index as a key as a last resort:

        const todoItems = todos.map((todo, index) =>
        <li key={index}>
            {todo.text}
        </li>
        )

10. What is context / context API?
    Context provides a way to pass data through the component tree without having to pass props down manually at every level.

    For example, authenticated user, locale preference, UI theme need to be accessed in the application by many components. 

        const {Provider, Consumer} = React.createContext(defaultValue)

11. Where in the React Lifecycle can you substitute useEffect(() => { })? 
    useEffect hook can act as 3 separate parts of the lifecycle. 
        1. componentDidMount / componentWillUnmount
            for a componentDidMount useEffect, all you need to do is provide some sort of logic within the useEffect and give it an empty dependecy array. This will cause whatever
            logic is inside of the useEffect to run immediately after the first render.
            On the other hand for componentWillUnmount, you can provide the useEffect with a 'cleanup function'. Give it a function with a return statement and you remove an element
            within it.
        2. componentDidUpdate?
            Based on the dependecy array, you can cause a re-render with your useEffect everytime that state in your dependency array is changed. This can be for example if you have 
            a counter that it going up every time you click a button. You can set the dependency array to the counter and provide logic within the useEffect so that everytime that 
            counter is changed, you re-render and run your logic.

12. How do you use CSS in React?
    There are many ways to utilize CSS in react. 
        1. The main way would be using a separate css file that is imported/injected into the component you want to style.
        2. Another way would be to use separate libraries that have CSS made already for you such as ReactStrap, BootStrap, Material-UI, etc.
        3. You can use Styled-components to manually style elements within a component.
        4. You can use in line styling directly within the elements by using a style tag.

13. Why can't you update state directly without setState()?
    setState will always trigger a re-render of the component. You only utilize the initial state render in your constructor. You want a re-render everytime state changes as then
    the changes will be seen.

14. What are Fragments and why are they better than container divs?
    It's common pattern in React which is used for a component to return multiple elements. Fragments let you group a list of children without adding extra nodes to the DOM.

        render() {
        return (
            <React.Fragment>
            <ChildA />
            <ChildB />
            <ChildC />
            </React.Fragment>
        )
        }
    There is also a shorter syntax, but it's not supported in many tools:

        render() {
        return (
            <>
            <ChildA />
            <ChildB />
            <ChildC />
            </>
        )
        }
    Below are the list of reasons,

    Fragments are a bit faster and use less memory by not creating an extra DOM node. This only has a real benefit on very large and deep trees.
    Some CSS mechanisms like Flexbox and CSS Grid have a special parent-child relationships, and adding divs in the middle makes it hard to keep the desired layout.
    The DOM Inspector is less cluttered.

15. Best Lifecycle methods for making API Calls? 
    componentDidMount makes sure that your dome is ready (you have rendered), before it is called. You can introduce an api call here as the state will initially get rendered,
    then the api call is made potentially changing the state.

16. What are hooks and what are they solving?
    It allows us to hook into the React Lifecycle methods without having to create a class component. 
    They also allow us to develop custom hooks that share logic across different components.

17. What is React?
    React is an open-source frontend JavaScript library which is used for building user interfaces especially for single page applications. It is used for handling view layer 
    for web and mobile apps. React was created by Jordan Walke, a software engineer working for Facebook. React was first deployed on Facebook's News Feed in 2011 and on 
    Instagram in 2012.

18. What are the major features of React?
    The major features of React are:
        It uses VirtualDOM instead of RealDOM considering that RealDOM manipulations are expensive.
        Supports server-side rendering.
        Follows Unidirectional data flow or data binding.
        Uses reusable/composable UI components to develop the view.

19. What is JSX?
    JSX is a XML-like syntax extension to ECMAScript (the acronym stands for JavaScript XML). Basically it just provides syntactic sugar for the React.createElement() 
    function, giving us expressiveness of JavaScript along with HTML like template syntax.

    In the example below text inside <h1> tag is returned as JavaScript function to the render function.

        class App extends React.Component {
        render() {
            return(
            <div>
                <h1>{'Welcome to React world!'}</h1>
            </div>
            )
        }
        }

20. How to create components in React?
    There are two possible ways to create a component.

    Function Components: This is the simplest way to create a component. Those are pure JavaScript functions that accept props object as first parameter and return React elements:

        function Greeting({ message }) {
        return <h1>{`Hello, ${message}`}</h1>

        }
    Class Components: You can also use ES6 class to define a component. The above function component can be written as:

        class Greeting extends React.Component {
        render() {
            return <h1>{`Hello, ${this.props.message}`}</h1>
        }
        }

21. When to use a Class Component over a Function Component?
    If the component needs state or lifecycle methods then use class component otherwise use function component. However, from React 16.8 with the addition of Hooks, you 
    could use state , lifecycle methods and other features that were only available in class component right in your function component.

22. How to bind methods or event handlers in JSX callbacks?
    There are 3 possible ways to achieve this:

    Binding in Constructor: In JavaScript classes, the methods are not bound by default. The same thing applies for React event handlers defined as class methods. 
    Normally we bind them in constructor.

        class Component extends React.Component {
        constructor(props) {
            super(props)
            this.handleClick = this.handleClick.bind(this)
        }

        handleClick() {
            // ...
        }
        }
    Public class fields syntax: If you don't like to use bind approach then public class fields syntax can be used to correctly bind callbacks.

        handleClick = () => {
        console.log('this is:', this)
        }
        <button onClick={this.handleClick}>
        {'Click me'}
        </button>
    Arrow functions in callbacks: You can use arrow functions directly in the callbacks.

        <button onClick={(event) => this.handleClick(event)}>
        {'Click me'}
        </button>

23. How to pass a parameter to an event handler or callback?
    You can use an arrow function to wrap around an event handler and pass parameters:

        <button onClick={() => this.handleClick(id)} />
        This is an equivalent to calling .bind:

        <button onClick={this.handleClick.bind(this, id)} />
    
    Apart from these two approaches, you can also pass arguments to a function which is defined as arrow function

        <button onClick={this.handleClick(id)} />
        handleClick = (id) => () => {
            console.log("Hello, your ticket number is", id)
        };

24. What are inline conditional expressions?
    You can use either if statements or ternary expressions which are available from JS to conditionally render expressions.
    Apart from these approaches, you can also embed any expressions in JSX by wrapping them in curly braces and then followed by JS logical operator &&.

        <h1>Hello!</h1>
        {
            messages.length > 0 && !isLogin?
            <h2>
                You have {messages.length} unread messages.
            </h2>
            :
            <h2>
                You don't have unread messages.
            </h2>
        }

25. What is Virtual DOM?
    The Virtual DOM (VDOM) is an in-memory representation of Real DOM. The representation of a UI is kept in memory and synced with the "real" DOM. 
    It's a step that happens between the render function being called and the displaying of elements on the screen. This entire process is called reconciliation.

26. What is React Fiber and what are its main goals?
    Fiber is the new reconciliation engine or reimplementation of core algorithm in React v16. The goal of React Fiber is to increase its suitability for areas like 
    animation, layout, gestures, ability to pause, abort, or reuse work and assign priority to different types of updates; and new concurrency primitives.

    The goal of React Fiber is to increase its suitability for areas like animation, layout, and gestures. Its headline feature is incremental rendering: the 
    ability to split rendering work into chunks and spread it out over multiple frames.

    from documentation

    Its main goals are:

    Ability to split interruptible work in chunks.
    Ability to prioritize, rebase and reuse work in progress.
    Ability to yield back and forth between parents and children to support layout in React.
    Ability to return multiple elements from render().
    Better support for error boundaries.

27. What are Higher-Order Components?

    A higher-order component (HOC) is a function that takes a component and returns a new component. Basically, it's a pattern that is derived from React's compositional nature.

    We call them pure components because they can accept any dynamically provided child component but they won't modify or copy any behavior from their input components.

    const EnhancedComponent = higherOrderComponent(WrappedComponent)
    HOC can be used for many use cases:

    Code reuse, logic and bootstrap abstraction.
    Render hijacking.
    State abstraction and manipulation.
    Props manipulation.

28. What is children prop? 
    Children is a prop (this.props.children) that allow you to pass components as data to other components, just like any other prop you use. Component tree put between 
    component's opening and closing tag will be passed to that component as children prop.

    There are a number of methods available in the React API to work with this prop. These include React.Children.map, React.Children.forEach, React.Children.count, 
    React.Children.only, React.Children.toArray.

    A simple usage of children prop looks as below,

        const MyDiv = React.createClass({
        render: function() {
            return <div>{this.props.children}</div>
        }
        })

        ReactDOM.render(
        <MyDiv>
            <span>{'Hello'}</span>
            <span>{'World'}</span>
        </MyDiv>,
        node
        )

29. How to write comments in React?
    The comments in React/JSX are similar to JavaScript Multiline comments but are wrapped in curly braces.

    Single-line comments:

        <div>
        {/* Single-line comments(In vanilla JavaScript, the single-line comments are represented by double slash(//)) */}
        {`Welcome ${user}, let's play React`}
        </div>
        Multi-line comments:

        <div>
        {/* Multi-line comments for more than
        one line */}
        {`Welcome ${user}, let's play React`}
        </div>

30. What is the purpose of using super constructor with props argument?

    A child class constructor cannot make use of this reference until super() method has been called. The same applies for ES6 sub-classes as well. 
    The main reason of passing props parameter to super() call is to access this.props in your child constructors.

    Passing props:

        class MyComponent extends React.Component {
        constructor(props) {
            super(props)

            console.log(this.props) // prints { name: 'John', age: 42 }
        }
        }
    Not passing props:

        class MyComponent extends React.Component {
        constructor(props) {
            super()

            console.log(this.props) // prints undefined

            // but props parameter is still available
            console.log(props) // prints { name: 'John', age: 42 }
        }

        render() {
            // no difference outside constructor
            console.log(this.props) // prints { name: 'John', age: 42 }
        }
        }
    The above code snippets reveals that this.props is different only within the constructor. It would be the same outside the constructor.

31. What is reconciliation?
    When a component's props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element 
    with the previously rendered one. When they are not equal, React will update the DOM. This process is called reconciliation.

32. How to set state with a dynamic key name?
    If you are using ES6 or the Babel transpiler to transform your JSX code then you can accomplish this with computed property names.

        handleInputChange(event) {
        this.setState({ [event.target.id]: event.target.value })
        }

33. What would be the common mistake of function being called every time the component renders?
    You need to make sure that function is not being called while passing the function as a parameter.

        render() {
        // Wrong: handleClick is called instead of passed as a reference!
        return <button onClick={this.handleClick()}>{'Click Me'}</button>
        }
    Instead, pass the function itself without parenthesis:

        render() {
        // Correct: handleClick is passed as a reference!
        return <button onClick={this.handleClick}>{'Click Me'}</button>
        }

34. Why React uses className over class attribute?
    class is a keyword in JavaScript, and JSX is an extension of JavaScript. That's the principal reason why React uses className instead of class. Pass a string as the className prop.

        render() {
        return <span className={'menu navigation-menu'}>{'Menu'}</span>
        }

35. What are stateless components? / StateFull components?
    StateLess: If the behaviour is independent of its state then it can be a stateless component. You can use either a function or a class for creating stateless components. 
    But unless you need to use a lifecycle hook in your components, you should go for function components. There are a lot of benefits if you decide to use function components here;
    they are easy to write, understand, and test, a little faster, and you can avoid the this keyword altogether.

    StateFull: If the behaviour of a component is dependent on the state of the component then it can be termed as stateful component. 
        import React, {useState} from 'react';

        const App = (props) => {
        const [count, setCount] = useState(0);

        return (
            // JSX
        )
        }

36. How to apply validation on props in React?
    When the application is running in development mode, React will automatically check all props that we set on components to make sure they have correct type. If the type is incorrect, 
    React will generate warning messages in the console. It's disabled in production mode due to performance impact. The mandatory props are defined with isRequired.
        import React from 'react'
        import PropTypes from 'prop-types'

        function User() {
        return (
            <>
            <h1>{`Welcome, ${this.props.name}`}</h1>
            <h2>{`Age, ${this.props.age}`}</h2>
            </>
        )
        }

        User.propTypes = {
            name: PropTypes.string.isRequired,
            age: PropTypes.number.isRequired
        }

37. What are the advantages of React?
    Below are the list of main advantages of React,

        Increases the application's performance with Virtual DOM.
        JSX makes code easy to read and write.
        It renders both on client and server side (SSR).
        Easy to integrate with frameworks (Angular, Backbone) since it is only a view library.
        Easy to write unit and integration tests with tools such as Jest.

38. What are the limitations of React?
    Apart from the advantages, there are few limitations of React too,

        React is just a view library, not a full framework.
        There is a learning curve for beginners who are new to web development.
        Integrating React into a traditional MVC framework requires some additional configuration.
        The code complexity increases with inline templating and JSX.
        Too many smaller components leading to over engineering or boilerplate.

39. What are error boundaries in React v16?
    Error boundaries are components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component 
    tree that crashed.
    A class component becomes an error boundary if it defines a new lifecycle method called componentDidCatch(error, info) or static getDerivedStateFromError() 

40. What is CRA and its benefits?
    The create-react-app CLI tool allows you to quickly create & run React applications with no configuration step.

    Let's create Todo App using CRA:

    # Installation
    $ npm install -g create-react-app

    # Create new project
    $ create-react-app todo-app
    $ cd todo-app

    # Build, test and run
    $ npm run build
    $ npm run test
    $ npm start
    It includes everything we need to build a React app:

    React, JSX, ES6, and Flow syntax support.
    Language extras beyond ES6 like the object spread operator.
    Autoprefixed CSS, so you don’t need -webkit- or other prefixes.
    A fast interactive unit test runner with built-in support for coverage reporting.
    A live development server that warns about common mistakes.
    A build script to bundle JS, CSS, and images for production, with hashes and sourcemaps.

41. Why we need to be careful when spreading props on DOM elements?
    When we spread props we run into the risk of adding unknown HTML attributes, which is a bad practice. 
    Instead we can use prop destructuring with ...rest operator, so it will add only required props.

    For example,

        const ComponentA = () =>
        <ComponentB isDisplay={true} className={'componentStyle'} />

        const ComponentB = ({ isDisplay, ...domProps }) =>
        <div {...domProps}>{'ComponentB'}</div>

42. What will happen if you use props in initial state?
    If the props on the component are changed without the component being refreshed, the new prop value will never be displayed because the constructor function 
    will never update the current state of the component. The initialization of state from props only runs when the component is first created.

    The below component won't display the updated input value:

        class MyComponent extends React.Component {
        constructor(props) {
            super(props)

            this.state = {
            records: [],
            inputValue: this.props.inputValue
            };
        }

        render() {
            return <div>{this.state.inputValue}</div>
        }
        }
    Using props inside render method will update the value:

        class MyComponent extends React.Component {
        constructor(props) {
            super(props)

            this.state = {
            record: []
            }
        }

        render() {
            return <div>{this.props.inputValue}</div>
        }
        }

43. Is it good to use setState() in componentWillMount() method?
    Yes, it is safe to use setState() inside componentWillMount() method. But at the same it is recommended to avoid async initialization in componentWillMount() 
    lifecycle method. componentWillMount() is invoked immediately before mounting occurs. It is called before render(), therefore setting state in this method will not 
    trigger a re-render. Avoid introducing any side-effects or subscriptions in this method. We need to make sure async calls for component initialization happened in 
    componentDidMount() instead of componentWillMount().

    componentDidMount() {
    axios.get(`api/todos`)
        .then((result) => {
        this.setState({
            messages: [...result.data]
        })
        })
    }

44. How do you conditionally render components?
    In some cases you want to render different components depending on some state. JSX does not render false or undefined, so you can use conditional short-circuiting to 
    render a given part of your component only if a certain condition is true.

        const MyComponent = ({ name, address }) => (
        <div>
            <h2>{name}</h2>
            {address &&
            <p>{address}</p>
            }
        </div>
        )
    If you need an if-else condition then use ternary operator.

        const MyComponent = ({ name, address }) => (
        <div>
            <h2>{name}</h2>
            {address
            ? <p>{address}</p>
            : <p>{'Address is not available'}</p>
            }
        </div>
        )

45. How you use decorators in React?
    You can decorate your class components, which is the same as passing the component into a function. Decorators are flexible and readable way of modifying component functionality.

        @setTitle('Profile')
        class Profile extends React.Component {
            //....
        }

        /*
        title is a string that will be set as a document title
        WrappedComponent is what our decorator will receive when
        put directly above a component class as seen in the example above
        */
        const setTitle = (title) => (WrappedComponent) => {
        return class extends React.Component {
            componentDidMount() {
            document.title = title
            }

            render() {
            return <WrappedComponent {...this.props} />
            }
        }
        }

46. How do you memoize a component?
    There are memoize libraries available which can be used on function components.

    For example moize library can memoize the component in another component.

         const MemoComponent = React.memo(function MemoComponent(props) {
            /* render using props */
        });
        OR
        export default React.memo(MyFunctionComponent);

47. How you implement Server Side Rendering or SSR?

    React is already equipped to handle rendering on Node servers. A special version of the DOM renderer is available, which follows the same pattern as on the client side.

    import ReactDOMServer from 'react-dom/server'
    import App from './App'

    ReactDOMServer.renderToString(<App />)

    This method will output the regular HTML as a string, which can be then placed inside a page body as part of the server response. On the client side, React detects the 
    pre-rendered content and seamlessly picks up where it left off.

48. What is the purpose of getDerivedStateFromProps() lifecycle method?
    The new static getDerivedStateFromProps() lifecycle method is invoked after a component is instantiated as well as before it is re-rendered. It can return an object 
    to update state, or null to indicate that the new props do not require any state updates.

        class MyComponent extends React.Component {
            static getDerivedStateFromProps(props, state) {
                // ...
            }
        }

49. Do Hooks replace render props and higher order components?
    Both render props and higher-order components render only a single child but in most of the cases Hooks are a simpler way to serve this by reducing nesting in your tree.

50. What is the recommended ordering of methods in component class?
    Recommended ordering of methods from mounting to render stage:

        static methods
        constructor()
        getChildContext()
        componentWillMount()
        componentDidMount()
        componentWillReceiveProps()
        shouldComponentUpdate()
        componentWillUpdate()
        componentDidUpdate()
        componentWillUnmount()
        click handlers or event handlers like onClickSubmit() or onChangeDescription()
        getter methods for render like getSelectReason() or getFooterContent()
        optional render methods like renderNavigation() or renderProfilePicture()
        render()

51. What is a switching component?
    A switching component is a component that renders one of many components. We need to use object to map prop values to components.

52. Why we need to pass a function to setState()?
    The reason behind for this is that setState() is an asynchronous operation. React batches state changes for performance reasons, so the state may not change immediately 
    after setState() is called. That means you should not rely on the current state when calling setState() since you can't be sure what that state will be. The solution is to 
    pass a function to setState(), with the previous state as an argument. By doing this you can avoid issues with the user getting the old state value on access due to the 
    asynchronous nature of setState().

    Let's say the initial count value is zero. After three consecutive increment operations, the value is going to be incremented only by one.
        // assuming this.state.count === 0
        this.setState({ count: this.state.count + 1 })
        this.setState({ count: this.state.count + 1 })
        this.setState({ count: this.state.count + 1 })
        // this.state.count === 0, not 3
    If we pass a function to setState(), the count gets incremented correctly.

        this.setState((prevState, props) => ({
        count: prevState.count + props.increment
        }))
        // this.state.count === 3 as expected

53. What is strict mode in React?
    React.StrictMode is a useful component for highlighting potential problems in an application. Just like <Fragment>, <StrictMode> does not render any extra DOM elements. 
    It activates additional checks and warnings for its descendants. These checks apply for development mode only.

54. What are the Pointer Events supported in React?
    Pointer Events provide a unified way of handling all input events. In the old days we had a mouse and respective event listeners to handle them but nowadays we have 
    many devices which don't correlate to having a mouse, like phones with touch surface or pens. We need to remember that these events will only work in browsers that 
    support the Pointer Events specification.

    The following event types are now available in React DOM:

        onPointerDown
        onPointerMove
        onPointerUp
        onPointerCancel
        onGotPointerCapture
        onLostPointerCapture
        onPointerEnter
        onPointerLeave
        onPointerOver
        onPointerOut

55. Why should component names start with capital letter? 
    If you are rendering your component using JSX, the name of that component has to begin with a capital letter otherwise React will throw an error as unrecognized tag. 
    This convention is because only HTML elements and SVG tags can begin with a lowercase letter.

        class SomeComponent extends Component {
        // Code goes here
        }
    You can define component class which name starts with lowercase letter, but when it's imported it should have capital letter. Here lowercase is fine:

        class myComponent extends Component {
        render() {
            return <div />
        }
        }

        export default myComponent

    While when imported in another file it should start with capital letter:
        import MyComponent from './MyComponent'

56. What is the difference between React and ReactDOM?
    The react package contains React.createElement(), React.Component, React.Children, and other helpers related to elements and component classes. You can think of these 
    as the isomorphic or universal helpers that you need to build components. The react-dom package contains ReactDOM.render(), and in react-dom/server we have server-side 
    rendering support with ReactDOMServer.renderToString() and ReactDOMServer.renderToStaticMarkup().

57. How to re-render the view when the browser is resized?
    You can listen to the resize event in componentDidMount() and then update the dimensions (width and height). You should remove the listener in componentWillUnmount() method.

    class WindowDimensions extends React.Component {
    constructor(props){
        super(props);
        this.updateDimensions = this.updateDimensions.bind(this);
    }
    
    componentWillMount() {
        this.updateDimensions()
    }

    componentDidMount() {
        window.addEventListener('resize', this.updateDimensions)
    }

    componentWillUnmount() {
        window.removeEventListener('resize', this.updateDimensions)
    }

    updateDimensions() {
        this.setState({width: window.innerWidth, height: window.innerHeight})
    }

    render() {
        return <span>{this.state.width} x {this.state.height}</span>
    }
    }

58. What are render props?
    Render Props is a simple technique for sharing code between components using a prop whose value is a function. The below component uses render prop which returns a React element.

        <DataProvider render={data => (
        <h1>{`Hello ${data.target}`}</h1>
        )}/>
    Libraries such as React Router and DownShift are using this pattern.

59.What is React Router?
    React Router is a powerful routing library built on top of React that helps you add new screens and flows to your application incredibly quickly, all while keeping 
    the URL in sync with what's being displayed on the page.

60. How React Router is different from history library?
    React Router is a wrapper around the history library which handles interaction with the browser's window.history with its browser and hash histories. It also provides 
    memory history which is useful for environments that don't have global history, such as mobile app development (React Native) and unit testing with Node.
        
61. What are the <Router> components of React Router v4?
    React Router v4 provides below 3 <Router> components:

        <BrowserRouter>
        <HashRouter>
        <MemoryRouter>
    The above components will create browser, hash, and memory history instances. React Router v4 makes the properties and methods of the history instance associated with 
    your router available through the context in the router object.

62. What is the purpose of push() and replace() methods of history?
    A history instance has two methods for navigation purpose.

        push()
        replace()
    If you think of the history as an array of visited locations, 
    push() will add a new location to the array and replace() will replace the current location in the array with the new one.

63. What is the purpose of the constants in Redux?
    Constants allows you to easily find all usages of that specific functionality across the project when you use an IDE. It also prevents you from introducing silly bugs 
    caused by typos – in which case, you will get a ReferenceError immediately.

    Normally we will save them in a single file (constants.js or actionTypes.js).

    export const ADD_TODO = 'ADD_TODO'
    export const DELETE_TODO = 'DELETE_TODO'
    export const EDIT_TODO = 'EDIT_TODO'
    export const COMPLETE_TODO = 'COMPLETE_TODO'
    export const COMPLETE_ALL = 'COMPLETE_ALL'
    export const CLEAR_COMPLETED = 'CLEAR_COMPLETED'
    In Redux, you use them in two places:

    During action creation:

    Let's take actions.js:

    import { ADD_TODO } from './actionTypes';

    export function addTodo(text) {
    return { type: ADD_TODO, text }
    }
    In reducers:

    Let's create reducer.js:

    import { ADD_TODO } from './actionTypes'

    export default (state = [], action) => {
    switch (action.type) {
        case ADD_TODO:
        return [
            ...state,
            {
            text: action.text,
            completed: false
            }
        ];
        default:
        return state
    }
    }

64. How to structure Redux top level directories?
    Most of the applications has several top-level directories as below:

        Components: Used for dumb components unaware of Redux.
        Containers: Used for smart components connected to Redux.
        Actions: Used for all action creators, where file names correspond to part of the app.
        Reducers: Used for all reducers, where files name correspond to state key.
        Store: Used for store initialization.
    This structure works well for small and medium size apps.

65. What is the difference between Real DOM and Virtual DOM?
    Below are the main differences between Real DOM and Virtual DOM,

            Real DOM	Virtual DOM
    Updates are slow	Updates are fast
    DOM manipulation is very expensive.	DOM manipulation is very easy
    You can update HTML directly.	You Can’t directly update HTML
    It causes too much of memory wastage	There is no memory wastage
    Creates a new DOM if element updates	It updates the JSX if element update

66. Can you list down top websites or applications using react as front end framework?
    Below are the top 10 websites using React as their front-end framework,

    Facebook
    Uber
    Instagram
    WhatsApp
    Khan Academy
    Airbnb
    Dropbox
    Flipboard
    Netflix
    PayPal

67. Do browsers understand JSX code?
    No, browsers can't understand JSX code. You need a transpiler to convert your JSX to regular 
    Javascript that browsers can understand. The most widely used transpiler right now is Babel.

68. What are synthetic events in React?
    SyntheticEvent is a cross-browser wrapper around the browser's native event. It's API is same as 
    the browser's native event, including stopPropagation() and preventDefault(), except the events 
    work identically across all browsers.